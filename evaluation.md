# Evaluation: running commentary

## Internal DSL

_Describe each change from your ideal syntax to the syntax you implemented, and
describe_ why _you made the change._

Many of the changes had to do with limitations with Scala (or at least what I could accomplish in it in a reasonable about of time). In fact, most of the changes can be described as making my "ideal" language more Scala-y. For example, comments are now made with a double slash instead of a pound sign. I also had to move away from a more Pythonic syntax to Scala's own syntax. So, state blocks don't start with a colon and are instead surrounded by curly brackets. Scala line indentation also applies. Since we have to use Scala for the internal DSL, we also have to run the code within an object that extends JFXApp and incldue import statements, which takes away from the clean interface of the original language. Another notable change is the addition of parentheses everywhere and the lack of spaces between many words. These were also forced by Scala's own contrains and the time I wanted to spend on this assignment.

One feature that I _added_ to the internal DSL was the "WhenIn" keyword to indicate that you were entering a state block. I spent a long time trying to get it working without a keyword beforehand, but implicit conversion and by-name parameters apparently do not mix well in Scala. Not even my hacky workarounds succeeded (I tried returning a function to do the same job as a by-name parameter like in my final WhenIn implementation). While I was somewhat forced to create WhenIn, it was actually kind of a nice addition and some people might actually prefer using it.

Other changes include requiring quotes around state names, which can actually be nice if your text editor has syntax highlighting, and eliminating some spaced between words for compactness and ease of implementation. The compact names also helped make the automatic completion in my text editor more useful. One feature I ended up droping was the ability to group directions when specifying constraints. In the original design, it was legal to say "If cannot move left or right or down...". This would not only have been more work for me, but could also annoy programmers if they needed even more parethesis to make this work (an alternative solution would be to create an object for every combinatin of directions, which could significantly affect compile times as there would be about 128 unique objects).

Finally, one last feature I added was a "runOnMaze" statement that allows the user to specify the map they want to use. As before, this was also kind of forced as I needed some way to know that all the rules had been specified and which map to load. This is something I didn't think about much in the design phase and would have been good to incorporate as it's currently ambiguous what map the code should be run on.

I would like to end by saying that despite all these changes, I was able to presearve most of the spirit of the original DSL. It it much, much easier to express thoughts in my DSL than in the original one. In some ways, I think the internal DSL may be even improved on my original design, even if many of the changes were somewhat forced by Scala. The internal DSL implementation also preserves the compactness and structure of the original design. If you quickly flip between the examples and the actual implementations, it is surprising how close they are to each other. It also keeps many of the cool features from the design, like automatically mapping names to state numbers (it even poroperly handles references to states that haven't been processed yet). It should also support many of the inference capabilities of the original design. If you leave out a state transition, it automatically infers you want to stay in the same state, and so on.

**On a scale of 1–10 (where 10 is "a lot"), how much did you have to change your syntax?**

If you count a lot of the "minor" changes due to Scala's syntax, then I might give this a 6 or so. The structure as a whole is very similar, but many of the details had to change (like colons into brakets or the addition of parenthesis since more than 1 parameter was used in my If and WhenIn functions).

**On a scale of 1–10 (where 10 is "very difficult"), how difficult was it to map your syntax to the provided API?**

The API itself wasn't much of an issue compared to implementing the rest of the DSL, but it did suck that the starter file provided did not document all of the behavior very well. I had to use some small hacks to work around not knowing many of the types in the API and it took a while to figue out how to actually run applications again (apparently JFXApp already includes App, which was nice for internal DSL code). So, I'd give it about a 3. It didn't get in my way a whole lot and I was able to work around issues relatively fast.

## External DSL

_Describe each change from your ideal syntax to the syntax you implemented, and
describe_ why _you made the change._

I am proud to say that my external DSL was able to correctly run my original example programs without modification. Well, with one small modification: the external DSL actually revealed two bugs in my original code (I refered to the state moveUp with moveUP, so the names didn't match). After I fixed that, it ran just fine. This is exciting because it means that I was able to get the more "advanced" functionality of the DSL working. So, no quotes around variable names, inference of the start state and state transitions, and chained logic (stuff like "cannot move up or left or right" is equivalent to "cannot move up and cannot move left and cannot move right"). I think having these features (or lack of syntax) is a nice "feature" of my DSL, so it was great to see it working. I'm also happy that I was able to easily get the full natural language syntax working. I think it really helps with readability and ease of use.

There was one or two things that I didn't implement that may have been expected of the original language. First of all, the lanugage does not support weird cases where you specify no conditions (so, you don't care whether any of the tiles around you are blocked). While this may be desirable if you wanted to exploit the order in which the rules were evaluated, this could also make code harder to follow (since you now have to figure out what you can infer from previous conditions). If you're moving, you should check to make sure you can actually move in that direction. If you're not moving and you're not checking anything around you, then why not elimiate the current state entirely or transition directly to the next state? If you _really_ want to do this, you can always write two rules that accomplish the same task (which is annoying, but still possible). My DSL also doesn't support infering that you do not want to move and you want to transition to the state you're already in. This would create an infinite loop, but it's still possible with my DSL (you just have to explicitly speficy that you're transitioning to the state you're in). Since these are generally behaviours you want to avoid, it's actually kind of a good thing that my DSL doesn't make them easy so that perhaps the programmer will realize that what they are doing is probably a bad idea. And, if they know what they're doing, they can still accomplish what they want.

**On a scale of 1–10 (where 10 is "a lot"), how much did you have to change your syntax?**

One, I guess. As stated above, I had to make zero changes to the code (besides bug fixes).

**On a scale of 1–10 (where 10 is "very difficult"), how difficult was it to map your syntax to the provided API?**

Somewhere around 5. It was one of those things that took a long time, but wasn't necessarily hard during the process. Part of why it took so long is because I revised previous code a lot, especially the AST. I originally went for more rules but found I could recycle some stuff from picolib (for instance, instead of creating more classes for directions, I ended up using their MoveDirection type). This was a doubly good move because it meant less converting between AST datatypes and picolib datatypes. It also took long because of the lack of documentation on picolib and JFXApp. I had to figure some things out for myself and spend a lot of time researching how to do things in Scala.

Another issue I ran into was with specifying how to parse the DSL. I wanted to enforce certain things like newlines or spaces in certain areas, but JavaTokenParsers / PackratParser did not make that easy. While it parses the example code just fine, I would like some reassurance that you can't do weird things like put two rules on one line.