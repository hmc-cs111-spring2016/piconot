# Design

## Who is the target for this design, e.g., are you assuming any knowledge on the part of the language users?
Given the complexity of the problem, the user will be expected to be familiar with how picobot works. So, they will already need to know that picobot has 100 possible states, that it can only check if there are walls to the north / south / east / west. They syntax also looks kind of like python's, so people who are familiar with python might have a slight edge (it was not my original idea to steal Python's syntax, but I found it helped make my code a lot more compact and was one of the last changes I made to my desigh).

## Why did you choose this design, i.e., why did you think it would be a good idea for users to express the maze-searching computation using this syntax?
I think there are two major changes that really help make writing programs easier in my design. First, states are named, not numbered. This helps the programmer keep track of what that state is supposed to accomplish or what they know is true in that state. Second, NEWS is replaced with up / right / down / left, which is more natural for the problem.

For better or worse, I tried to make the syntax more natural so that it is easier for the programmer to express their thoughts and for a reader to determine the programmer's intentions. While natural language programming is generally a bad idea, I think this syntax is unambiguous and much easier to understand than before. This should help reduce the cognitive load of converting between ideas in your head and code. In fact, I think the syntax may even make most of the comments unnecessary as it flows really well.

In later iterations of my design, I also tried to remove repeated elements out of the code by modifying the design itself. For instance, it makes a lot of sense to define rules starting in a particular state next to each other, so I moved the starting state out of the rules and grouped them by their starting state. I also heavily rely on implicit behavior to prevent the natural language code from getting too long. Most rules can be written in less than 80 characters without much effort at all. In fact, the longest line of code (excluding comments) is 69 characters in example-ideal.txt and 52 characters in example-ideal-maze.txt.

## What behaviors are easier to express in your design than in Picobot’s original design?  If there are no such behaviors, why not?
The natural language syntax makes handling states, wildcards, not moving, and staying in the same state really easy because you don't really have to express them at all. Each different state name is implicity a different state number, so the programmer doesn't have to keep track of which number state does what (since there is no "state 0", the starting state is the first one in the code). Wildcards are automatically generated when the programmer's logic does not depend on whether they can move in a direction or not, don't moves are automatically generated when the programmer doesn't specify a movement direction, and transitions to the same state are automatically generated if the programmer doesn't specify a state transition. This helps keep programs short (despite the verbosity of natural language) and helps the programmer focus on the trickier parts of the implementation.

## What behaviors are more difficult to express in your design than in Picobot’s original design? If there are no such behaviors, why not?
While the design is very different, the logic and concepts are largely the same. So, ignoring that my design is more verbose, you can express logic at least as easily as in the original design.

## On a scale of 1–10 (where 10 is “very different”), how different is your syntax from PicoBot’s original design?
About 8 or so. The only similarity between the two designs is that it follows roughly the same order (current state, pattern, movement direction, next state). I didn't give it a higher score because I feel like it might be possible to create higher-level logic in this language. For example, the logic "move in a certain direction until you cannot anymore" may be used often in robot programming and a really great DSL might make it easy to do these kinds of common things. For what it's worth, it still is pretty easy and fast to do this in my design (you could do it in 55 characters (including newlines) with 1-character state names).

## Is there anything you would improve about your design?
Like I said above, adding some pre-defined logic could simplify the process or creating an advanced program. It would have also been nice to test CS 5 students on how they liked the natural language aspect as it may not work well with how some people think (though it can't really be worse than the original design, so at least it wouldn't make programming harder for some students).

P.S. After working on implementing the internal and external DSLs, I have realized a few flaws in the original design and bugs in the example code. However, rather than change these, I decided to leave them as they are (except for this commment) so that you can see my original thoughts and code. If you want to see what flaws / bugs I found, I have documented them in my evaulation of the DSL implementations in evaluation.md.